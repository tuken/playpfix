package repo

/**
  * Dao for action table
  */
trait ActionDao {
  /**
    * Find the action by ID
    * @param id the action ID
    * @return the ActionRow
    */
  def findById(id: Long): Future[Option[Tables.ActionRow]]

  /**
    * save a new action
    * @param name the action name
    * @return The action ID generated by MySQL
    */
  def save(name: String): Future[Long]
}

case class ActionDaoImpl(db: Database) extends ActionDao {
  private implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(5))

  override def findById(id: Long): Future[Option[Tables.ActionRow]] = {
    val query: Query[Tables.Action, Tables.Action#TableElementType, Seq] = Action.filter(_.id === id)
    val action = query.result.headOption
    db.run(action)
  }

  override def save(name: String): Future[Long] = {
    val query = Action.map(a => (a.name))
    val actions = (for {
      actionInsert <- query += (name)
      actionId <- sql"SELECT LAST_INSERT_ID()".as[(Long)].head
    } yield actionId).transactionally
    db.run(actions)
  }
}

import models.{Alias, Tables}
import play.api.db.slick.DatabaseConfigProvider
import play.api.db.slick.HasDatabaseConfigProvider
import slick.driver.JdbcProfile

import scala.concurrent.Future
import java.util.Date

import com.google.common.collect.Tables
import io.netty.util.concurrent.Future
import org.joda.time.DateTime
import play.api.mvc.Action

//@Singleton()
//class AliasRepository @Inject() (protected val dbConfigProvider: DatabaseConfigProvider) extends AliasTable with HasDatabaseConfigProvider[JdbcProfile] {
//
//  import driver.api._
//
//  def insert(alias: Alias): Future[Int] = db.run { aliasesQueryInc += alias }
//
//  def insertAll(aliases: List[Alias]): Future[Seq[Int]] = db.run { aliasesQueryInc ++= aliases }
//
//  def update(alias: Alias): Future[Int] = db.run { aliasesQuery.filter(_.id === alias.id).update(alias) }
//
//  def delete(id: Int): Future[Int] = db.run { aliasesQuery.filter(_.id === id).delete }
//
//  def getAll(): Future[List[Alias]] = db.run { aliasesQuery.to[List].result }
//
//  def getById(aliasId: Int): Future[Option[Alias]] = db.run { aliasesQuery.filter(_.id === aliasId).result.headOption }
//
//  def ddl = aliasesQuery.schema
//}
//
//private[repo] trait AliasTable { self: HasDatabaseConfigProvider[JdbcProfile] =>
//
//  import driver.api._
//
//  private[AliasTable] class AliasTable(tag: Tag) extends Table[Alias](tag, "alias") {
//    val id: Rep[Int] = column[Int]("id", O.AutoInc, O.PrimaryKey)
//    val domain_id: Rep[Int] = column[Int]("domain_id")
//    val address: Rep[String] = column[String]("address", O.Length(255, varying = true), O.Default(""))
//    val goto: Rep[String] = column[String]("goto", O.SqlType("TEXT"))
//    val created_at: Rep[DateTime] = column[DateTime]("created_at")
//    val updated_at: Rep[DateTime] = column[DateTime]("updated_at")
//    val active: Rep[Boolean] = column[Boolean]("active", O.Default(true))
////    def emailUnique = index("email_unique_key", email, unique = true)
//    def * = (id, domain_id, address, goto, created_at, updated_at, active) <> (Alias.tupled, Alias.unapply)
//  }
//
//  lazy protected val aliasesQuery = TableQuery[Alias]
//
//  lazy protected val aliasesQueryInc = aliasesQuery returning aliasesQuery.map(_.id)
//}
